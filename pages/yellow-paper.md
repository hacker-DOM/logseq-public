- [[yellow-paper-math-notation]]
- why study the yellow paper?
	- you will learn how to read mathematics
	- you will learn how to understand complex codebases
	- you will learn evm
	- reference for specs
	- hardest part of this course
	- high-level call:
		- function ping() returns (a, b, c)
		- ...
		- (a, b, c) = c.ping()
	- low-level call:
		- (bool success, bytes memory data) = c.call{value: 3 eth}abi.encode....)
		- require(success);
	- differences between HLC and LLC:
		- HLCs do contract existence check! (impelemented EXTCODESIZE eg using OZ Address.isContract)
		- HLC require(success)
			- LLC don't!
- ch 4, 6
	- $\sigma$  |  world state
	- $\sigma_{t+1} = \Pi(\sigma_t, B)$  |  block-level STF
	- $B = (..., (T_0, T_1,...),...)$
	- $\Pi(\sigma, B) = \Omega(B, \Upsilon(\Upsilon(\sigma, T_0),T_1)...)$ | block-finalization STF
	- $\sigma' = \Upsilon(\sigma, T)$  |  post-transactional state
	- $(\Upsilon^g, \Upsilon^l, \Upsilon^z)$
	- $A = (A_s, A_l, A_t, A_r, A_a, A_K)$  |  substate
	- two types of transactions - legacy and Type 1
	- $T=(T_x, T_n, T_p, T_g, T_t, T_v, T_i/T_d, T_w, T_r, T_s)$
		- what's missing?
	- $v_0 = T_gT_p + T_v$  | up-front cost
	- $\sigma_0 = \sigma$ except:
		- $T_gT_p$ deducted
			- why not $T_gT_p + T_v$?
		- Nonce incremented
	- $A^* = A^0$ except
		- Add to accessed accounts `msg.sender`
		- for Type 1, add to accessed accounts "warmed up" addresses from $T_A$
		- and to accessed keys warmed up keys from $T_A$
	- $g = T_g - g_0$
		- what is $g_0$ (intrinsic gas)?
	- execute transaction
	- $A^0$ -> $A^*$ (add info from transaction) -> exec -> $A$ -> $A'$ (add self-destructs to refund counter)
	- $g_0$ intrinsic -> $g = T_g - g_0$ -> exec -> $g'$ -> $g^*$ (add refund $A_r'$)
	- $\sigma$ -> $\sigma_0$ (deduct ether)-> exec -> $\sigma_P$ -> $\sigma^*$ (give ether to sender & miner) -> $\sigma'$ (delete self-destructed and touched but empty accounts)
- ch 8: message call:
	- $\sigma$ -> $\sigma_1$ (transfer eth (value))-> $\Omega$ -> $\sigma^{**}$ (can be $\empty$) -> $\sigma'$
- ch 9: execution model:
	- $I = (I_a, I_o, I_p, I_d, I_s, I_v, I_b, I_H, I_e, I_w)$
	- $\Xi = X$:
		- $O$
	- $\sigma$ -> $\sigma'$
- assignment
	- read the YPC and/or the Python specs
	- take notes
	- what have you learned?