- Types
	- newly declared variables have a default value dependent on its type
	- || and && short-circuit
	- `uint` = `uint256`, `int` = `int256`
	- max type value:
		- in the past: `uint(-1)`
			- now this is a compilation error
		- now: `type(uint).max`
	- arithmetic is checked by default
	- intermezzo: two's complement
		- 0 â€¦ (2^255 - 1)Â Â  => positives
			- how many **positive** numbers are there?
				- (2^255 - 1) - (1) + 1 = 2^255 - 1
		- 2^255Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  => -2^255
		- 2^256 - 1Â Â Â Â Â Â Â Â Â Â Â  => -1
			- how many negative numbers?
			- (2^256 - 1) - (2^255)  + 1 = (2*2^255 - 1) - (2^255) + 1 = 2^255
		- eg for uint8:
			- 0 = 0
			- 1 = 1
			- 2 = 2
			- ...
			- 255 = 255
		- eg for int8:
			- 1 zero, 127 positive, 128 negative
			- encoding:
				- raw = interpreted
				- 0 = 0
				- 1 .. 127 = positives
				- 128 (0x80) = -128
				- 129 = -127
				- ...
				- 255 = -1
			- 1 = -1 + 2 = 0xff + 0x02 = 0x01 = 1
			- -1 + 2 = 0x80 + 0x02 = 0x82 = -3
		- there is one more negative number than positive!
	- bit operations are performed on two's complement (for signed numbers (integers))
		- eg, `~int(0) == int(-1)`
			- in two's complement:
				- `int(0) == 0...0`
				- `~int(0) == 1...1`
				- `int(-1)` == `1...1`
	- shifts
		- type of shift operation has type of left operand
			- BUT can be different sign
				- eg `int8(127) << 1 == -2` (why?)
		- right operand must be unsigned type (otherwise compilation error)
		- `x << y == x * 2**y mod 2**256`
		- `x >> y == x / 2**y` (rounded down (towards negative infinity))
			- before 0.5.0, this rounded towards zero (so up for negative `x`)
		- overflow checks are _not_ performed on shift operations!
	- `-x` only works for signed ints
	- if `x = type(int).min`, then:
		- in an unchecked block:
			- `x == -x`
		- otherwise:
			- `-x` will result in runtime error
	- division
		- 5 / 2 = 2
		- -5 / 2 = -2 (rounding towards zero)
		- NOT: -5 / 2 = -3 (rounding towards negative infinity)
		- division on literals results in fractional values (of arbitrary precision)
		- division by zero causes Panic (even in `unchecked`)
		- division can cause overflow:
			- `type(int).min / (-1)`
		- (and multiplication: `type(int).min * (-1)`)
	- modulo
		- do modulo on absolute values
			- then assign sign of left operand
				- eg:
					- -5 % -2 == -1
					- -5 % 2 == -1
					- 5 % -2 == 1
					- 5 % 2 == 1
		- modulo with zero causes a Panic (even in `unchecked`)
	- exponentiation
		- type is equal to type of the base
		- exponent must be unsigned
		- 0**0 == 1
	- address
		- `address`
		- `address payable`
			- also has `.transfer` and `.send`
		- `address payable => address` implicit conversion
			- explicit conversion also possible for `uint160`, integer literals, `bytes20`, contract types
		- `address => address payable` explicit conversion `payable(addr)`
			- in `addr` is contract then possible only if it has receive or payable fallback function
		- `.transfer`
			- reverts on failure
		- `.send`
			- does not revert
			- returns success (true/false)
		- `.call`, `.delegatecall`, `.staticcall`
			- take single `bytes memory` parameter and return `(bool success, bytes memory returndata)`
			- `{gas: }` option available on all three
			- `{value: }` only available on `.call`
		- `.callcode` has been removed in 0.5
		- `.code` and `.codehash`
			- `.code` returns `bytes memory`
			- `.codehash` returns `bytes32`
		- all contracts can be converted to address (so eg `address(this).balance`)
	- contracts
		- implicitly convert to (syntactic) contracts they inherit from
		- explicitly convert to/from
			- `address`
			- `address payable` - if contract has receive or payable fallback
				- still performed with `address(contr)`
				- otherwise - `payable(address(contr))`
		- operators
			- none
	- fixed-size byte arrays
		- `bytes1`, ..., `bytes32`
		- left-aligned
		- operators
			- comparisons
			- bit operators
			- shift operators
				- RHS must be unsigned
				- return type is same
			- !!! index access (read-only)
		- members:
			- `.length`
		- Note
			- `bytes1[]` is an array of bytes, but due to padding rules, it wastes 31 bytes of space for each element (except in storage) (so use `bytes`)
	- literals
		- hexadecimal literals that are >= 39 and <= 41 digits long:
			- if they pass checksum test => they are `address`
			- otherwise: compile error (you can prefix it with zeros (for integer types) or postfix it with zeros (for bytesN types) to make it larger)
		- integer literals
			- no leading zeros
		- scientific notation
			- MeE
				- mantissa can be fractional but exponent has to be integer
				- eg `2e10`, `-2e10`, `2e-10`, `2.5e1`
		- underscores: `123_000`, `0x2eff_abde`, `1_2e345_678`
		- number literal expressions have arbitrary precision until they are converted to a non-literal type
			- => computations do not overflow and divisions do not truncate in number literal expressions
			- except:
				- ternary operator
					- eg `255 + (true ? 1 : 0)` overflows
				- array subscript
					- eg `255 + [1, 2, 3][0]` overflows
		- any operator that can be applied to integers can also be applied to number literal expressions
			- as long as the operands are integers
			- if any of two is fractional:
				- bit operations are disallowed
				- if the exponent is fractional, exponentiation is disallowed
			- shift and exponentiation with literals as left/base:
				- if number is positive: treat it as `uint256`
				- if it's negative: treat it as `int256`
		- Note:
			- number literal expressions are converted to non-literal as soon as they are used with non-literal expressions
			- eg this will not be accepted:
			- ```
			  uint128 a = 1;
			  uint128 b = 2.5 + a + 0.5;
			  ```
			- (at `2.5 + a`, the compiler can't find a common type between `2.5` and `a`)
		- string literals
			- double or single quotes
			- `"foo" "bar"` == `"foobar"`
			- implicitly converted to
				- `bytes1`, ..., `bytes32` if they fit
				- to `bytes`
				- to `string`
			- can contain
				- ascii chars (0x20 - 0x7E)
				- escapes:
					- `\<newline>`, `\\`, `\'`, `\"`, `\n`, `\r`, `\t`,
					- `\xNN`,
						- takes a hex value and inserts appropriate byte
					- `\uNNNN`
						- takes a Unicode codepoint and inserts a UTF-8 sequence
			- these two return the same thing:
			- ```
			  contract C {
			      function main() public pure returns (bytes32) {
			          return "\
			  abc";
			      }
			  
			      function main2() public pure returns (bytes32) {
			          return ""
			              "abc";
			      }
			  }
			  ```
			- ```
			  "\n\"\'\\abc\
			  def"
			  
			  ```
				- this string has a length of 10 bytes
			- unicode literals
				- can contain any utf-8 sequence
				- also support same escape sequences
				- `string memory a = unicode"Hello ðŸ˜ƒ";`
			- hexadecimal literals
				- prefixed with `hex`
				- can use `_` between byte boundaries
				- `hex"00112233"Â hex"44556677"` equivalent to `hex"0011223344556677"`
				- are not explicitly convertible to `string`
		- enums
			- explicitly convertible to/from integer types
				- `Panic`s if value is not within enum bounds
			- default value is first member
			- `type(MyEnum).min`, `type(MyEnum).max`
			- Note:
				- can also be top-level
		- user-defined value types
			- allows creating zero-cost abstraction over an elementary value type
				- (similar to alias, but with stricter type requirements)
			- `type NewType is BuiltinValueType`
				- `NewType.wrap`, `NewType.unwrap`
			- `NewType` doesn't have any operators or attached member functions
				- (even `==` is not defined)
			- implicit & explicit conversions are not allowed
			- data representation and ABI type is same as underlying type.
		- function types
			- can be assigned from a function
			- can be used to pass functions to and return functions from function calls
			- two types
				- internal
					- can only be called in current code unit
						- contract
						- internal library functions
						- inherited functions
					- calling it just means jumping to the entry label
				- external
					- consist of
						- address
						- function signature
					- can be passed via and returned from external function calls
				- internal by default
					- (this isn't true for functions declared in contracts, where visibility is mandatory)
				- conversions
					- `A` is implicitly convertible to `B` iff
						- these are identical:
							- parameter types
							- return types
							- internal/external
						- and:
							- state mutability of `A` is more restrictive than `B`
								- `pure` functions can be converted to `view` and `non-payable`
								- `view` functions can be converted to `non-payable`
								- `payable` functions can be converted to `non-payable`
					- no other conversions between function types are possible
				- ... [skipping the rest of this section]
		- reference types
			- structs, arrays, mappings
			- data location
				- memory
				- storage
				- calldata
					- try to use this bc it will avoid copies and make sure data cannot be modified
					- arrays and structs with calldata location can also be returned from functions, but you can't allocate them [hmm]
				- function visibility
					- private/internal - all three
					- public/external - memory & calldata
			- assignment or type conversion that changes data location will lead to copying
				- not all pairs are possible
			- arrays
				-
			-
			-
	- exercises:
		- let b = `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC`
		- what is `address(uint160(bytes20(b)))`?
		- what is `address(uint160(uint256(b)))`?
		-