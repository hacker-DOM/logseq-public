- ether units
	- `1 wei == 1`
	- `1 gwei == 1e9`
	- `1 ether == 1e18`
	- cannot be applied to variables
		- use `variable * 1 ether`
- time units
	- `1 seconds == 1`
	- `1 minutes == 60`
	- `1 hours == 3600`
	- `1 days == 24 * 3600`
	- `1 weeks == 7 * 24 * 3600`
	- cannot be applied to variables
		- use `variable * 1 days`
- special variables and functions
	- _always_ exist in global namespace
	- `blockhash(uint block_num)`: hash of block when `block_num` is one 256 most recent blocks, otherwise zero
	- block
		- `basefee`: `uint`: current block's base fee
		- `chainid`: `uint`: current chain id
		- `coinbase`: `address payable`: current block miner's address
		- `difficulty`: `uint`:
			- if evm < paris: current block difficulty
			- else: `block.prevrandao`
		- `gaslimit`: `uint`: current block gaslimit
		- `number`: `uint`: current block number
		- `prevrandao`: `uint`: random number provided by the beacon chain (for evm >= paris)
		- `timestamp`: `uint`: current block timestamp
		- `gasleft()`: `uint`: remaining gas
		- `msg.data`: `bytes calldata`: complete calldata
		- `msg.sender`: `address`: sender of the message (current call)
		- `msg.sig`: `bytes4`: first four bytes of the calldata
		- `msg.value`: `uint`: message value
		- `tx.gasprice`: `uint`: gas price of the transaction
		- `tx.origin`: `address`: sender of the transaction
			- easy phishing target
- abi encoding and decoding functions
	- abi.decode
		- eg: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes)`
	- abi.encode
		- eg: `data = abi.encode(a, b, c)`
	- abi.encodePacked
		- eg: `data = abi.encodePacked(a, b, c)`
		- dangerous!
	- abi.encodeWithSelector
		- eg: `data = abi.encodeWithSelector("deadbeef", a, b, c)`
	- abi.encodeWithSignature
		- eg: `data = abi.encodeWithSignature("foo(uint,uint,uint)", a, b, c)`
	- abi.encodeCall
		- eg: `data = abi.encodeCall(foo, (a, b, c)`
- members of bytes and string
	- `bytes/string.concat(b1, bs, b2)`
- error handling
	- `assert(bool cond)`
	- `require(bool cond)`
	- `require(bool cond, string memory msg)`
	- `revert()`
	- `revert(string memory msg)`
- math and crypto funcs
	- `addmod(uint a, uint b, uint m)`
		- `(a+b) % m`
		- addition is performed with arbitrary precision (doesn't wrap around `2**256`)
		- `m` can't be 0
	- `mulmod(uint a, uint b, uint m)`
		- `(a * b) % m`
		- same ^
	- `sha256(bytes memory) -> bytes32`
	- `ripemd160(bytes memory) -> bytes20`
	- `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) -> address`
		- ...
	- members of address type
		- ...
	-